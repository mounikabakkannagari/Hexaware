MAVEN COMMANDS:

>>> mvn clean   :-    This command cleans the maven project by deleting the target directory.
   
   Syntax: $ mvn clean

>>> mvn compiler:compile  :- This command compiles the java source classes of the maven project.

   Syntax: $ mvn compiler:compile

>>> mvn compiler:testCompile :- This command compiles the test classes of the maven project.

   Syntax: $ mvn compiler:testCompile

>>> mvn package :-This command builds the maven project and packages them into a JAR,WAR,etc

   Syntax: $ mvn package

>>> mvn install :- this command builds the maven project and installs the project files to the local repository
   
   Syntax: $ mvn install

>>> mvn deploy :- This command is used to deploy the artifact to the remote repository.
   
    syntax: $ mvn deploy

>>> mvn validate :- This command validates the maven project that everything is correct and all the necessary information is available.
   
    Syntax : $ mvn validate

>>> mvn dependency:tree :- This command generates the dependency tree of the maven project.
   
    syntax : $ mvn dependency:tree

>>> mvn dependency:analyze :- This command analyzes the maven project to identify the unused declared and used undeclared dependencies.
   
    Syntax : $ mvn dependency:analyze

>>> mvn archetype:generate :- Maven archetypes is a maven project templating toolkit. We can use this command to generate a skeleton maven project of different types, such as JAR, web application, maven site, etc.
   
    Syntax : $ mvn archetype:generate

>>> mvn site:site :- This command generates a site for the project

    Syntax : $ mvn site:site

>>> mvn test :- This command is used to run the test cases of the project

    Syntax : $ mvn test

>>> mvn compile :- It’s used to compile the source Java classes of the project.

    Syntax : $ mvn compile
>>> mvn verify :- This command build the project, runs all the test cases and run any checks on the results of the integration
    
                  tests to ensure quality criteria are met.

>>> mvn -help :- This command prints the maven usage and all the available options for us to use

MAVEN LIFE CYCLE:

Maven is a powerful project management tool that is based on POM (project object model), used for projects build, dependency and documentation. 

It is a tool that can be used for building and managing any Java-based project. Maven makes the day-to-day work of Java developers easier and helps with the building and 

running of any Java-based project.

Maven Lifecycle: Below is a representation of the default Maven lifecycle and its 8 steps: Validate, Compile, Test, Package, Integration test, 

Verify, Install and Deploy.

The default Maven lifecycle consists of 8 major steps or phases for compiling, testing, building and installing a given Java project as specified below:

Validate: This step validates if the project structure is correct. For example – It checks if all the dependencies have been downloaded and are available in the local repository.

Compile: It compiles the source code, converts the .java files to .class and stores the classes in target/classes folder.

Test: It runs unit tests for the project.

Package: This step packages the compiled code in distributable format like JAR or WAR.

Integration test: It runs the integration tests for the project.

Verify: This step runs checks to verify that the project is valid and meets the quality standards.

Install: This step installs the packaged code to the local Maven repository.

Deploy: It copies the packaged code to the remote repository for sharing it with other developers.

Maven follows a sequential order to execute the commands where if you run step n, all steps preceding it (Step 1 to n-1) are also executed.

For example – if we run the Installation step (Step 7), it will validate, compile, package and verify the project along with running unit and 

integration tests (Step 1 to 6) before installing the built package to the local repository.

 Maven commands : mvn --version : it will show which version we are suing 

		        mvn -- compile: It will compile the source code of the project

			   mvn --test : Runs tests for the project

			   mvn  -- install : deploys the packaged war file to the local repository 

			   mvn --clean : cleans the project and removes all files generated by the previous build.

>> WHAT IS WEB SERIVCES? 

A web service is any service that −

->Is available over the Internet or private (intranet) networks

->Uses a standardized XML messaging system

->Is not tied to any one operating system or programming language

->Is self-describing via a common XML grammar

->Is discoverable via a simple find mechanism

>> Web services methods:

-> get: It is used to get all the data and records from the database.

-> post: It is used to add new data and records to the database.

-> put: It is used to udate the data using id or name in the database.

-> delete: It is used to delete the data from the database.

>>>> GIT LIFE CYCLE

A typical git project life cycle contains following actions. Consider a central repository containing the project files. 

This is located in a remote location and can be accessed using project URL. Clone the remote central repository to create a local repository. 

Now the local repository contains all project files from remote central repository.

git COMMANDS:
			git init : It is used to start a new repository

			git add : IT is used to add the file in staging area

			git commit : this command records or snapshots the file permanently in the version history.

			git pull : This command fetches and merges changes on the remote server to your working directory.
			
			git push : This command sends the committed changes of master branch to your remote repository.
			
			git checkout : This command is used to switch from one branch to another.
				
			git checkout -b : It is used to change the branch
			
			git checkout -d : It is used to change the branch
			
			git log : It is used to see the history of the repository
			
			git reset : Undo local changes to the state of git repo
			
			git revert :used for undoing changes to a repository's commit history.
			
			git merge :It is used to make changes to other repository

>>> CENTRALIZED vs DISTRIBUTED version control :


In centralized source control, there is a server and a client. The server is the master repository that contains all of the versions of the code. To work on any project, 

firstly user or client needs to get the code from the master repository or server. So the client communicates with the server and pulls all the code or current version of 

the code from the server to their local machine. In other terms we can say, you need to take an update from the master repository and then you get the local copy of the 

code in your system. So once you get the latest version of the code, you start making your own changes in the code and after that, you simply need to commit those changes
 
straight forward into the master repository. Committing a change simply means merging your own code into the master repository or making a new version of the source code. 

So everything is centralized in this model. There will be just one repository and that will contain all the history or version of the code and different branches of the code. 

So the basic workflow involves in the centralized source control is getting the latest version of the code from a central repository that will contain other people’s code as well, 

making your own changes in the code, and then committing or merging those changes into the central repository. 



In distributed version control most of the mechanism or model applies the same as centralized. 

The only major difference you will find here is, instead of one single repository which is the server, here every single developer or client has their own server and they will have 

a copy of the entire history or version of the code and all of its branches in their local server or machine. Basically, every client or user can work locally and disconnected which 

is more convenient than centralized source control and that’s why it is called distributed. 

It doesn’t follow the way of communicating or merging the code straight forward to the master repository after making changes. Firstly you commit all the changes in your own server or

 repository and then the ‘set of changes’ will merge to the master repository. 
You don’t need to rely on the central server, you can clone the entire history or copy of the code to your hard drive. So when you start working on a project, you clone the code from the master repository in your own hard drive, then you get the code from your own repository to make changes and after doing changes, you commit your changes to your local repository and at this point, your local repository will have ‘change sets‘ but it is still disconnected with the master repository (master repository will have different ‘sets of changes‘ from each and every individual developer’s repository), so to communicate with it, you issue a request to the master repository and push your local repository code to the master repository. Getting the new change from a repository is called “pulling” and merging your local repository’s ‘set of changes’ is called “pushing“. 


